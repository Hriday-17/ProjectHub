import { NextRequest } from 'next/server';
import { cookies } from 'next/headers';
import jwt, { JwtPayload } from 'jsonwebtoken';
import { AUTH_ERRORS, ApiErrorResponse } from './api-error';
import { supabase } from './supabase-client';

// Ensure JWT secret is available
const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) {
  throw new Error('JWT_SECRET is not defined in environment variables');
}

export interface JWTPayload extends JwtPayload {
  userId: string;
  email: string;
  role: 'student' | 'mentor' | 'admin';
  isVerified: boolean;
}

/**
 * Verifies the authentication token and returns the decoded payload
 * @throws {ApiErrorResponse} If token is invalid or missing
 */
export async function verifyAuth(req: NextRequest): Promise<JWTPayload> {
  const cookieStore = cookies();
  const token = cookieStore.get('auth-token')?.value;

  if (!token) {
    throw new ApiErrorResponse(AUTH_ERRORS.UNAUTHORIZED);
  }

  try {
    if (!JWT_SECRET) {
      throw new ApiErrorResponse(AUTH_ERRORS.SERVER_ERROR);
    }

    // Verify JWT
    const decoded = jwt.verify(token, JWT_SECRET) as JWTPayload;
    
    // Verify user still exists in Supabase
    const { data: user, error } = await supabase
      .from('users')
      .select('id, is_verified')
      .eq('id', decoded.userId)
      .single();

    if (error || !user) {
      const cookieStore = cookies();
      cookieStore.delete('auth-token');
      throw new ApiErrorResponse(AUTH_ERRORS.UNAUTHORIZED);
    }

    if (!user.is_verified && decoded.isVerified) {
      // Token claims user is verified but they're not - revoke access
      const cookieStore = cookies();
      cookieStore.delete('auth-token');
      throw new ApiErrorResponse(AUTH_ERRORS.EMAIL_NOT_VERIFIED);
    }

    return decoded;
  } catch (error) {
    if (error instanceof ApiErrorResponse) {
      throw error;
    }
    const cookieStore = cookies();
    cookieStore.delete('auth-token');
    throw new ApiErrorResponse(AUTH_ERRORS.UNAUTHORIZED);
  }
}

/**
 * Generates a new JWT token
 */
export function generateToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
  if (!JWT_SECRET) {
    throw new ApiErrorResponse(AUTH_ERRORS.SERVER_ERROR);
  }
  return jwt.sign(payload, JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRY || '24h',
    algorithm: 'HS256'
  });
}

/**
 * Sets the authentication cookie
 */
export function setAuthCookie(token: string): void {
  const cookieStore = cookies();
  cookieStore.set('auth-token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    path: '/',
    maxAge: 86400, // 24 hours
  });
}

/**
 * Clears the authentication cookie
 */
export function clearAuthCookie(): void {
  const cookieStore = cookies();
  cookieStore.delete('auth-token', {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    path: '/'
  });
}
}
